---
layout: post
title: Automatiser une pratique dans un alias
tags:
- alias
- linux
status: draft
type: post
published: false
meta:
  _edit_last: '4'
---
Je me déplace sur une machine distante dans un but bien précis. Si je vais sur la machine qui héberge les logs, c'est pour les consulter et je reproduis la même séquence :
<ul>
	<li>ssh user@machine</li>
	<li>cd /repertoire/log/</li>
	<li>ls</li>
</ul>

Au début, j'avais automatisé la première opération :
<pre lang="bash">alias recette-log='ssh user@machine'</pre>

Comme je perdais ensuite du temps à chercher le bon répertoire (diffèrent suivant les environnements), j'ai ajouté le cd :
<code>alias recette-log='ssh user@machine <strong>-t "cd /repertoire/log/ ; bash" </strong>'</code>

Et comme je fais toujours un ls en arrivant :
<code>alias recette-log='ssh user@machine -t "cd /repertoire/log/"  <strong>; ls</strong> ; bash'</code>
<pre>
web_service    site_web    batch_quartz    bus_de_donnees
</pre>
Ensuite, parmi ces réperoires je me rends dans celui qui abrite les log de l'application qui m'intéressent.

Quand je répète souvent la même séquence, elle gagne à être automatisée (ssh + cd + ls). Lorsque j'arrive au moment où l'opération que je fais dépend du contexte, j'affiche toutes les alternatives possibles.

Par exemple, quand je vais sur un serveur d'application, je ne fais pas toujours la même opération : parfois je relance le serveur, parfois je recharge le contexte. Un message d'accueil m'indique alors ce que je peux exécuter :
<pre>
restart_tomcat
restart_context
</pre>

Les alias évolue en même temps que l'architecture. Par exemple avions un cluster rabbitMQ sur lequel nous faisions <code>rabbitmqctl list_connections</code>
<pre>alias itg-bus01='ssh barreverte@bus01.fr -t "rabbitmqctl list_connections; bash"'</pre>

Puis nous avons ajouté un système de reprise sur erreur (failover) qui s'appuie sur heartbeat. L'alias a alors évolué :
<pre>alias itg-bus01='ssh barreverte@bus01.fr -t "sudo crm status; bash"'</pre>
