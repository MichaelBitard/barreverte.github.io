---
layout: post
title: '[chroot 0] Diffuser les avancées en équipe : du wiki à l''environnement standard'
tags:
- philippe
- linux
- standard
status: private
type: post
published: false
meta:
  _edit_last: '4'
---
La connaissance est le bien le plus précieux sur un code legacy. Elle se trouve dans la tête des développeurs, parfois dans la tête d'un seul qui a réussi à configurer une appli ou trouver de meilleures options pour analyser un incident.

Dans sa sphère d'excellence ce développeur sait exécuter une tâche plus efficacement que les autres.

Pour propager chaque avancée au sein de l'équipe nous avons cheminé par trois étapes, qui constituent autants de niveaux de maturité :
<ol>
	<li>le wiki</li>
	<li>les scripts</li>
	<li>l'environnement standard</li>
</ol>

<strong>Le wiki</strong>
Il contient toujours des erreurs, qu'il faut corriger. Rébarbatif, ce travail sans fin aboutit au syndrome de la doc jamais à jour, syndrome qui a notamment amené aux spécifications exécutables.

<strong>Les scripts</strong>
Une étape supplémentaire : automatiser les procédures dans des scripts. L'inconvénient : chaque petite différence entre postes menace de le mettre en défaut. Qu'un nom de répertoire différe et le script devient inopérent.


Nous travaillons sur une infrastructure grand public complexe : plusieurs front-end, plusieurs back-end, des dizaines de batch. Les petites différences d'un poste à l'autre compliquent l'installation et la mise à jour de toutes ces applications sur un poste.

Prenons un exemple. En amont de nos services, un équipement réseaux nous impose le vénérable encodage ISO-8859  qu'ubuntu a délaissé pour utf-8 depuis longtemps. Petit à petit, faire fonctionner notre code en iso devenait un exploit. Pour arréter l'hémoragie, nous avons configuré en iso l'environnement standard, qu'il suffisait de récupérer pour avoir un poste fonctionnel.

Pourquoi ne pas simplement renseigner la marche à suivre dans un wiki ? Parce-que les différences d'environnment d'un poste à l'autre rendent fragile la procédure du wiki.



<strong>L'environnement mutualisé</strong>
Quand l'environnement est mutualisé il suffit qu'une personnes fasse une mise à jour pour que tout le monde puisse en bénéficier : le gain de temps est égal au nombre de membres de l'équipe. Il y a un seul script dont connaître l'emplacement : celui qui installe et met à jour l'environnement standard.


<strong>Réduire les différences qui n'apportent pas de valeur</strong>



<strong>Capturer une connaissance</strong>

Dans une équipe, des gens font certaines taches d'une manière plus efficace que d'autres :
<ul>
	<li> Jean utilise une astuce pour accélérer les déploiements dans tomcat.</li>
	<li> Marc sait afficher finement le status du bus de données</li>
	<li> Paul connaît l'emplacement des log d'une machine peu visitée.</li>
</ul>
Ces connaissances uniques à chaque personne méritent d'être capturés d'une manière pérenne. Prenons comme exemple des logs remontés via UDP sur des machines loghost :
<ul>
	<li>recette nourrit le répertoire /nfs-recette de la machine barre-dev.fr accessible avec le user barreverte</li>
	<li>bench nourrit un autre répertoire (/nfs-dev) sur la même machine</li>
	<li>la production nourrit le répertoire /log-prod d'une autre machine loghost-prod.fr, accessible avec le user server</li>
</ul>

users, noms de répertoire et nom de machines sont différents et mal normalisés. Pour une dizaine de machines, le nombre de combinaisons possibles user@machine:repertoire grimpe vite. A chaque fois que je cherche des log, je me demande c'est dans quel répertoire déjà ? Je pose la question à mon voisin. Il ne sait pas non plus (au bout de 18 mois sur le projet). Quand j'ai enfin trouvé l'information, je l'automatise en combinant les alias et l'option (méconnue) -t de ssh.
<pre>
alias recette-log='ssh barreverte@barre-dev.fr -t "cd /nfs-recette" '
alias prod-log='ssh server@loghost-prod.fr -t "cd /log-prod"'
...
</pre>
Non seulement cette connaissance est écrite quelque part, mais elle est maintenant automatisée.

<strong>propager un standard</strong>
 Dans notre cas, nous ajoutons ces connaissances dans un standard matérialisé sous la forme d'un chroot.
Toutes ces automatisations sont ainsi disponibles pour tous les membres de l'équipe.
